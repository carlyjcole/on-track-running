{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { memo, useMemo, useRef, useEffect } from \"react\";\nimport Typed from \"typed.js\";\nexport const ReactTyped = memo(_a => {\n  var {\n      style,\n      className,\n      typedRef,\n      parseRef: transformRef,\n      stopped,\n      children,\n      startWhenVisible\n    } = _a,\n    typedOptions = __rest(_a, [\"style\", \"className\", \"typedRef\", \"parseRef\", \"stopped\", \"children\", \"startWhenVisible\"]);\n  const rootElement = useRef(null);\n  const shouldUpdateArgs = useMemo(() => {\n    var _a;\n    return [...Object.values(typedOptions).filter(v => typeof v === \"boolean\" || typeof v === \"number\" || typeof v === \"string\"), (_a = typedOptions.strings) === null || _a === void 0 ? void 0 : _a.join(\",\")];\n  }, [typedOptions]);\n  useEffect(() => {\n    const element = transformRef && transformRef(rootElement) || rootElement.current;\n    const typed = new Typed(element, Object.assign({}, typedOptions));\n    if (stopped || startWhenVisible) {\n      typed === null || typed === void 0 ? void 0 : typed.stop();\n    }\n    if (startWhenVisible) {\n      const observer = new IntersectionObserver(([entry]) => {\n        if (entry.isIntersecting) {\n          typed === null || typed === void 0 ? void 0 : typed.start();\n          observer.disconnect();\n        }\n      });\n      observer.observe(element);\n    }\n    if (typedRef && typed) {\n      typedRef(typed);\n    }\n    return () => {\n      typed.destroy();\n    };\n  }, shouldUpdateArgs);\n  const child = !children ? React.createElement(\"span\", {\n    style: style,\n    ref: rootElement\n  }) : React.cloneElement(children, {\n    ref: rootElement\n  });\n  return React.createElement(\"span\", {\n    style: style,\n    className: className,\n    \"data-testid\": \"react-typed\"\n  }, child);\n});\nexport { Typed };","map":{"version":3,"names":["React","memo","useMemo","useRef","useEffect","Typed","ReactTyped","_a","style","className","typedRef","parseRef","transformRef","stopped","children","startWhenVisible","typedOptions","__rest","rootElement","shouldUpdateArgs","Object","values","filter","v","strings","join","element","current","typed","assign","stop","observer","IntersectionObserver","entry","isIntersecting","start","disconnect","observe","destroy","child","createElement","ref","cloneElement"],"sources":["/Users/carlycole/personal-projects/on-track/on-track/node_modules/react-typed/src/index.tsx"],"sourcesContent":["import React, { memo, useMemo, useRef, useEffect } from \"react\";\nimport Typed from \"typed.js\";\nexport interface ReactTypedProps {\n  /**\n   * strings to be typed\n   * @default [\n    'These are the default values...',\n    'You know what you should do?',\n    'Use your own!',\n    'Have a great day!',\n  ]\n   * */\n  strings?: string[];\n  /**\n   * ID or instance of HTML element of element containing string children\n   * @default null\n   */\n  stringsElement?: string | Element;\n  /**\n   * type speed in milliseconds\n   * @default 0\n   */\n  typeSpeed?: number;\n  /**\n   * time before typing starts in milliseconds\n   * @default 0\n   */\n  startDelay?: number;\n  /**\n   * backspacing speed in milliseconds\n   * @default 0\n   */\n  backSpeed?: number;\n  /**\n   * only backspace what doesn't match the previous string\n   * @default true\n   */\n  smartBackspace?: boolean;\n  /**\n   * shuffle the strings\n   * @default true\n   */\n  shuffle?: boolean;\n  /**\n   * time before backspacing in milliseconds\n   * @default 700\n   */\n  backDelay?: number;\n  /**\n   * Fade out instead of backspace\n   * @default false\n   */\n  fadeOut?: boolean;\n  /**\n   * css class for fade animation\n   * @default typed-fade-out\n   */\n  fadeOutClass?: string;\n  /**\n   * Fade out delay in milliseconds\n   * @default 500\n   */\n  fadeOutDelay?: number;\n  /**\n   * loop strings\n   * @default false\n   */\n  loop?: boolean;\n  /**\n   * amount of loops\n   * @default Infinity\n   */\n  loopCount?: number;\n  /**\n   * show cursor\n   * @default true\n   */\n  showCursor?: boolean;\n  /**\n   * character for cursor\n   * @default |\n   */\n  cursorChar?: string;\n  /**\n   * insert CSS for cursor and fadeOut into HTML\n   * @default true\n   */\n  autoInsertCss?: boolean;\n  /**\n   * attribute for typing Ex: input placeholder, value, or just HTML text\n   * @default null\n   */\n  attr?: string;\n  /**\n   * bind to focus and blur if el is text input\n   * @default false\n   */\n  bindInputFocusEvents?: boolean;\n  /**\n   * 'html' or 'null' for plaintext\n   * @default html\n   */\n  contentType?: string;\n  /**\n   * Before it begins typing the first string\n   */\n  onBegin?(self: Typed): void;\n  /**\n   * All typing is complete\n   */\n  onComplete?(self: Typed): void;\n  /**\n   * Before each string is typed\n   */\n  preStringTyped?(arrayPos: number, self: Typed): void;\n  /**\n   * After each string is typed\n   */\n  onStringTyped?(arrayPos: number, self: Typed): void;\n  /**\n   * During looping, after last string is typed\n   */\n  onLastStringBackspaced?(self: Typed): void;\n  /**\n   * Typing has been stopped\n   */\n  onTypingPaused?(arrayPos: number, self: Typed): void;\n  /**\n   * Typing has been started after being stopped\n   */\n  onTypingResumed?(arrayPos: number, self: Typed): void;\n  /**\n   * After reset\n   */\n  onReset?(self: Typed): void;\n  /**\n   * After stop\n   */\n  onStop?(arrayPos: number, self: Typed): void;\n  /**\n   * After start\n   */\n  onStart?(arrayPos: number, self: Typed): void;\n  /**\n   * After destroy\n   */\n  onDestroy?(self: Typed): void;\n  /**\n   * Styles for the outer element\n   * */\n  style?: React.CSSProperties;\n  /**\n   * class name for the outer element\n   * */\n  className?: string;\n  /**\n   * callback that returns the typed instance\n   * */\n  typedRef?: (typed: Typed) => void;\n  /**\n   * if true will be initialized in stopped state\n   * @default false\n   * */\n  stopped?: boolean;\n  /**\n   * In some custom component dom element is not in the ref.current property.\n   * ie an Input by antd the element is in input property ( ref.current.input )\n   * you can use this function to get the element from the ref\n   * @default (ref)=>ref.current\n   * */\n  parseRef?: (ref: React.RefObject<any>) => HTMLElement;\n  /**\n   * if true will start only when the element is visible\n   * @default false\n   * */\n  startWhenVisible?: boolean;\n  children?: React.ReactElement;\n}\n\nexport const ReactTyped: React.FC<ReactTypedProps> = memo(\n  ({\n    style,\n    className,\n    typedRef,\n    parseRef: transformRef,\n    stopped,\n    children,\n    startWhenVisible,\n    ...typedOptions\n  }) => {\n    const rootElement = useRef<any>(null);\n    const shouldUpdateArgs = useMemo(\n      () => [\n        ...Object.values(typedOptions).filter(\n          (v) =>\n            typeof v === \"boolean\" ||\n            typeof v === \"number\" ||\n            typeof v === \"string\"\n        ),\n        typedOptions.strings?.join(\",\"),\n      ],\n      [typedOptions]\n    );\n    useEffect(() => {\n      const element =\n        (transformRef && transformRef(rootElement)) || rootElement.current;\n      const typed = new Typed(element, { ...typedOptions });\n\n      if (stopped || startWhenVisible) {\n        typed?.stop();\n      }\n\n      if (startWhenVisible) {\n        const observer = new IntersectionObserver(([entry]) => {\n          if (entry.isIntersecting) {\n            typed?.start();\n            observer.disconnect();\n          }\n        });\n        observer.observe(element);\n      }\n\n      if (typedRef && typed) {\n        typedRef(typed);\n      }\n      return () => {\n        typed.destroy();\n      };\n    }, shouldUpdateArgs);\n\n    const child = !children ? (\n      <span style={style} ref={rootElement} />\n    ) : (\n      React.cloneElement(children, {\n        ref: rootElement,\n      })\n    );\n    return (\n      <span style={style} className={className} data-testid=\"react-typed\">\n        {child}\n      </span>\n    );\n  }\n);\n\nexport { Typed };\n"],"mappings":";;;;;;;;AAAA,OAAOA,KAAK,IAAIC,IAAI,EAAEC,OAAO,EAAEC,MAAM,EAAEC,SAAS,QAAQ,OAAO;AAC/D,OAAOC,KAAK,MAAM,UAAU;AAkL5B,OAAO,MAAMC,UAAU,GAA8BL,IAAI,CACtDM,EASA,IAAI;MATJ;MACCC,KAAK;MACLC,SAAS;MACTC,QAAQ;MACRC,QAAQ,EAAEC,YAAY;MACtBC,OAAO;MACPC,QAAQ;MACRC;IAAgB,IAAAR,EAEjB;IADIS,YAAY,GAAAC,MAAA,CAAAV,EAAA,EARhB,yFASA,CADgB;EAEf,MAAMW,WAAW,GAAGf,MAAM,CAAM,IAAI,CAAC;EACrC,MAAMgB,gBAAgB,GAAGjB,OAAO,CAC9B,MAAK;;IAAC,QACJ,GAAGkB,MAAM,CAACC,MAAM,CAACL,YAAY,CAAC,CAACM,MAAM,CAClCC,CAAC,IACA,OAAOA,CAAC,KAAK,SAAS,IACtB,OAAOA,CAAC,KAAK,QAAQ,IACrB,OAAOA,CAAC,KAAK,QAAQ,CACxB,EACD,CAAAhB,EAAA,GAAAS,YAAY,CAACQ,OAAO,cAAAjB,EAAA,uBAAAA,EAAA,CAAEkB,IAAI,CAAC,GAAG,CAAC,CAChC;GAAA,EACD,CAACT,YAAY,CAAC,CACf;EACDZ,SAAS,CAAC,MAAK;IACb,MAAMsB,OAAO,GACVd,YAAY,IAAIA,YAAY,CAACM,WAAW,CAAC,IAAKA,WAAW,CAACS,OAAO;IACpE,MAAMC,KAAK,GAAG,IAAIvB,KAAK,CAACqB,OAAO,EAAAN,MAAA,CAAAS,MAAA,KAAOb,YAAY,EAAG;IAErD,IAAIH,OAAO,IAAIE,gBAAgB,EAAE;MAC/Ba,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEE,IAAI,EAAE;IACf;IAEA,IAAIf,gBAAgB,EAAE;MACpB,MAAMgB,QAAQ,GAAG,IAAIC,oBAAoB,CAAC,CAAC,CAACC,KAAK,CAAC,KAAI;QACpD,IAAIA,KAAK,CAACC,cAAc,EAAE;UACxBN,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEO,KAAK,EAAE;UACdJ,QAAQ,CAACK,UAAU,EAAE;QACvB;MACF,CAAC,CAAC;MACFL,QAAQ,CAACM,OAAO,CAACX,OAAO,CAAC;IAC3B;IAEA,IAAIhB,QAAQ,IAAIkB,KAAK,EAAE;MACrBlB,QAAQ,CAACkB,KAAK,CAAC;IACjB;IACA,OAAO,MAAK;MACVA,KAAK,CAACU,OAAO,EAAE;IACjB,CAAC;EACH,CAAC,EAAEnB,gBAAgB,CAAC;EAEpB,MAAMoB,KAAK,GAAG,CAACzB,QAAQ,GACrBd,KAAA,CAAAwC,aAAA;IAAMhC,KAAK,EAAEA,KAAK;IAAEiC,GAAG,EAAEvB;EAAW,EAAI,GAExClB,KAAK,CAAC0C,YAAY,CAAC5B,QAAQ,EAAE;IAC3B2B,GAAG,EAAEvB;GACN,CACF;EACD,OACElB,KAAA,CAAAwC,aAAA;IAAMhC,KAAK,EAAEA,KAAK;IAAEC,SAAS,EAAEA,SAAS;IAAA,eAAc;EAAa,GAChE8B,KAAK,CACD;AAEX,CAAC,CACF;AAED,SAASlC,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}